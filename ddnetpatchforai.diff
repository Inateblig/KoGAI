diff --git a/CMakeLists.txt b/CMakeLists.txt
index 38dae4940..788a1eb77 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -187,7 +187,7 @@ else()
 endif()
 
 set(SERVER_EXECUTABLE DDNet-Server CACHE STRING "Name of the built server executable")
-set(CLIENT_EXECUTABLE DDNet CACHE STRING "Name of the build client executable")
+set(CLIENT_EXECUTABLE DDNet-AI CACHE STRING "Name of the build client executable")
 
 ########################################################################
 # Compiler flags
@@ -1674,6 +1674,12 @@ add_custom_command(OUTPUT "src/game/generated/wordlist.h"
 
 # Sources
 set_src(BASE GLOB_RECURSE src/base
+  #For ai
+  cycbuf.cpp
+  cycbuf.h
+  util.h
+  do.h
+
   color.h
   detect.h
   dynamic.h
@@ -1971,6 +1977,10 @@ if(CLIENT)
     video.h
   )
   set_src(GAME_CLIENT GLOB_RECURSE src/game/client
+    #For ai
+    area.cpp
+    area.h
+
     animstate.cpp
     animstate.h
     component.cpp
diff --git a/src/base/cycbuf.cpp b/src/base/cycbuf.cpp
new file mode 100644
index 000000000..f79df5433
--- /dev/null
+++ b/src/base/cycbuf.cpp
@@ -0,0 +1,39 @@
+#include <string.h>
+
+#include "util.h"
+#include "cycbuf.h"
+
+void
+cbinit(struct cycbuf *cb, FPARS(size_t, elsz, nelm), void *buf)
+{
+	cb->elsz = elsz;
+	cb->nelm = nelm;
+	cb->nea = cb->fp = 0;
+	cb->buf = buf;
+}
+
+void
+cbadd(struct cycbuf *cb, void *elp)
+{
+	memcpy(cbelmat(cb, cb->fp + cb->nea), elp, cb->elsz);
+
+	if (cb->nea < cb->nelm)
+		cb->nea++;
+	else
+		cb->fp++;
+}
+
+void *
+cbget(struct cycbuf *cb)
+{
+	if (!cb->nea)
+		return 0;
+	cb->nea--;
+	return cbelmat(cb, cb->fp++);
+}
+
+void *
+cbelmat(struct cycbuf *cb, size_t idx)
+{
+	return (char *)cb->buf + idx % cb->nelm * cb->elsz;
+}
diff --git a/src/base/cycbuf.h b/src/base/cycbuf.h
new file mode 100644
index 000000000..db9004744
--- /dev/null
+++ b/src/base/cycbuf.h
@@ -0,0 +1,11 @@
+struct cycbuf {
+	size_t elsz;
+	size_t nelm;
+	size_t nea, fp;
+	void *buf;
+};
+
+void cbinit(struct cycbuf *cb, FPARS(size_t, elsz, nelm), void *buf);
+void cbadd(struct cycbuf *cb, void *elp);
+void *cbget(struct cycbuf *cb);
+void *cbelmat(struct cycbuf *cb, size_t idx);
diff --git a/src/base/do.h b/src/base/do.h
new file mode 100644
index 000000000..a0e036807
--- /dev/null
+++ b/src/base/do.h
@@ -0,0 +1,106 @@
+/* do.h */
+
+#define do2r(W, B, A, J)\
+	B W(0, x) A J\
+	B W(1, y) A
+#define do2rv(W, B, A, J, ...)\
+	B W(0, x, __VA_ARGS__) A J\
+	B W(1, y, __VA_ARGS__) A
+
+#define do2(W)\
+	do {\
+		W(0, x)\
+		W(1, y)\
+	} while (0)
+
+#define do2e(E, J)\
+	(\
+		(E(0, x)) J\
+		(E(1, y))\
+	)
+
+#define do2xz(W)\
+	do {\
+		W(0, x)\
+		W(2, z)\
+	} while (0)
+
+#define do2ryx(W, B, A, J)\
+	B W(1, y) A J\
+	B W(0, x) A
+
+#define do3r(W, B, A, J)\
+	B W(0, x) A J\
+	B W(1, y) A J\
+	B W(2, z) A
+#define do3rv(W, B, A, J, ...)\
+	B W(0, x, __VA_ARGS__) A J\
+	B W(1, y, __VA_ARGS__) A J\
+	B W(2, z, __VA_ARGS__) A
+
+#define do3(W)\
+	do {\
+		W(0, x)\
+		W(1, y)\
+		W(2, z)\
+	} while (0)
+#define do3v(W, ...)\
+	do {\
+		W(0, x, __VA_ARGS__)\
+		W(1, y, __VA_ARGS__)\
+		W(2, z, __VA_ARGS__)\
+	} while (0)
+
+#define do3e(E, J)\
+	(\
+		(E(0, x)) J\
+		(E(1, y)) J\
+		(E(2, z))\
+	)
+#define do3ev(E, J, ...)\
+	(\
+		(E(0, x, __VA_ARGS__)) J\
+		(E(1, y, __VA_ARGS__)) J\
+		(E(2, z, __VA_ARGS__))\
+	)
+
+#define do4(W)\
+	do {\
+		W(0, x)\
+		W(1, y)\
+		W(2, z)\
+		W(3, w)\
+	} while (0)
+#define do4v(W, ...)\
+	do {\
+		W(0, x, __VA_ARGS__)\
+		W(1, y, __VA_ARGS__)\
+		W(2, z, __VA_ARGS__)\
+		W(3, w, __VA_ARGS__)\
+	} while (0)
+
+#define do4r(W, B, A, J)\
+	B W(0, x) A J\
+	B W(1, y) A J\
+	B W(2, z) A J\
+	B W(3, w) A
+#define do4rv(W, B, A, J, ...)\
+	B W(0, x, __VA_ARGS__) A J\
+	B W(1, y, __VA_ARGS__) A J\
+	B W(2, z, __VA_ARGS__) A J\
+	B W(3, w, __VA_ARGS__) A
+
+#define do4e(E, J)\
+	(\
+		(E(0, x)) J\
+		(E(1, y)) J\
+		(E(2, z)) J\
+		(E(3, w))\
+	)
+#define do4ev(E, J, ...)\
+	(\
+		(E(0, x, __VA_ARGS__)) J\
+		(E(1, y, __VA_ARGS__)) J\
+		(E(2, z, __VA_ARGS__)) J\
+		(E(3, w, __VA_ARGS__))\
+	)
diff --git a/src/base/system.cpp b/src/base/system.cpp
index ae12c834b..83dccdb51 100644
--- a/src/base/system.cpp
+++ b/src/base/system.cpp
@@ -936,7 +936,8 @@ int64_t time_get()
 int64_t time_freq()
 {
 	using namespace std::chrono_literals;
-	return std::chrono::nanoseconds(1s).count();
+	/* for ai */
+	return std::chrono::nanoseconds(1s).count()/1;
 }
 
 int64_t time_get_nanoseconds()
diff --git a/src/base/util.h b/src/base/util.h
new file mode 100644
index 000000000..f5eec5381
--- /dev/null
+++ b/src/base/util.h
@@ -0,0 +1,78 @@
+#define NELM(X) (sizeof (X) / sizeof (X)[0])
+
+#define eprintf(...) fprintf(stderr, __VA_ARGS__)
+
+extern const char *prognm;
+#if DBG
+//	#define perrpref()
+//		eprintf("%s: %s[%d]:%s: ", prognm, __FILE__, __LINE__, __func__)
+	#define perrpref() do {} while (0)
+	#define dbgf(...) perrf(__VA_ARGS__)
+#else
+	#define perrpref() eprintf("%s: ", prognm)
+	#define dbgf(...) 0
+#endif
+
+
+#define perrnand(DOWHAT, ...)\
+	do {\
+		perrpref();\
+		eprintf(__VA_ARGS__);\
+		eprintf(": %s\n", strerror(errno));\
+		DOWHAT;\
+	} while (0)
+#define perrfand(DOWHAT, ...)\
+	do {\
+		perrpref();\
+		eprintf(__VA_ARGS__);\
+		eprintf("\n");\
+		DOWHAT;\
+	} while (0)
+
+#define perrn(...) perrnand(, __VA_ARGS__)
+#define perrf(...) perrfand(, __VA_ARGS__)
+#define ferrn(...) perrnand(exit(1), __VA_ARGS__)
+#define ferrf(...) perrfand(exit(1), __VA_ARGS__)
+
+#define MIN(X, Y) ((X) < (Y) ? X : (Y))
+#define MAX(X, Y) ((X) > (Y) ? X : (Y))
+#define CLAMP(X, A, B) ((X) < (A) ? A : (X) > (B) ? B : (X))
+
+#define RET(V)\
+	do {\
+		rv = (V);\
+		goto befret;\
+	} while (0)
+
+#define SWAP(A, B)\
+	do {\
+		char t_[sizeof A];\
+		memcpy(t_, &(A), sizeof t_);\
+		memcpy(&(A), &(B), sizeof t_);\
+		memcpy(&(B), t_, sizeof t_);\
+	} while (0)
+
+#define intern static
+
+#define PPCAT(A, B) A##B
+#define PPECAT(A, B) PPCAT(A, B)
+#define PPARG8(_0, _1, _2, _3, _4, _5, _6, _7, _8, ...) _8
+#define PPNARGS(...) PPARG8(__VA_ARGS__, 8, 7, 6, 5, 4, 3, 2, 1)
+
+#define FPARS(T, ...)\
+	PPECAT(FPARS, PPNARGS(__VA_ARGS__))(T, __VA_ARGS__)
+
+#define FPARS2(T, A, B)\
+	T A, T B
+#define FPARS3(T, A, B, C)\
+	T A, T B, T C
+#define FPARS4(T, A, B, C, D)\
+	T A, T B, T C, T D
+#define FPARS5(T, A, B, C, D, E)\
+	T A, T B, T C, T D, T E
+#define FPARS6(T, A, B, C, D, E, F)\
+	T A, T B, T C, T D, T E, T F
+#define FPARS7(T, A, B, C, D, E, F, G)\
+	T A, T B, T C, T D, T E, T F, T G
+#define FPARS8(T, A, B, C, D, E, F, G, H)\
+	T A, T B, T C, T D, T E, T F, T G, T H
diff --git a/src/engine/client/ai.h b/src/engine/client/ai.h
new file mode 100644
index 000000000..4d50ec185
--- /dev/null
+++ b/src/engine/client/ai.h
@@ -0,0 +1,13 @@
+#include <game/generated/protocol.h>
+
+#define ai_NRAYS 8
+#define ai_RAYLEN (32 * 16)
+
+extern CNetObj_PlayerInput ai_inp;
+extern int ai_gaveinp;
+extern int ai_selfkill;
+extern int ai_availjumps;
+extern int ai_isdone;
+extern int ai_CID;
+extern float ai_htds[ai_NRAYS];
+extern float ai_ftds[ai_NRAYS];
diff --git a/src/engine/client/client.cpp b/src/engine/client/client.cpp
index 6c8ecce98..9d3539acf 100644
--- a/src/engine/client/client.cpp
+++ b/src/engine/client/client.cpp
@@ -52,6 +52,9 @@
 #include <game/version.h>
 
 #include <engine/client/demoedit.h>
+// for ai
+
+#include <engine/client/ai.h>
 
 #if defined(CONF_FAMILY_WINDOWS)
 #define WIN32_LEAN_AND_MEAN
@@ -66,6 +69,32 @@
 #include "video.h"
 #endif
 
+#include <sys/stat.h>
+#include <base/util.h>
+#include "fifo.h"
+
+CNetObj_PlayerInput ai_inp;
+int ai_gaveinp;
+int ai_selfkill;
+int ai_availjumps;
+int ai_isdone;
+int ai_CID = -1;
+float ai_htds[ai_NRAYS];
+float ai_ftds[ai_NRAYS];
+
+void openfifo(struct fifo *f, const char *mode) {
+	struct stat st;
+
+	if (!(f->fnm = getenv(f->evnm)))
+		ferrf("%s env variable is unset", f->evnm);
+	if (stat(f->fnm, &st))
+		ferrn("stat: %s", f->fnm);
+	if ((st.st_mode & S_IFMT) != S_IFIFO)
+		ferrf("%s: not a fifo file", f->fnm);
+	if (!(f->f = fopen(f->fnm, mode)))
+		ferrn("fopen: %s", f->fnm);
+}
+
 #include "SDL.h"
 #ifdef main
 #undef main
@@ -81,6 +110,9 @@
 #include <chrono>
 #include <thread>
 
+const char *prognm;
+struct fifo fifoout, fifoin;
+
 using namespace std::chrono_literals;
 
 static const ColorRGBA ClientNetworkPrintColor{0.7f, 1, 0.7f, 1.0f};
@@ -4370,13 +4402,9 @@ int main(int argc, const char **argv)
 	bool Silent = false;
 	bool RandInitFailed = false;
 
-	for(int i = 1; i < argc; i++)
-	{
-		if(str_comp("-s", argv[i]) == 0 || str_comp("--silent", argv[i]) == 0)
-		{
+	for (int i = 1; i < argc; i++)
+		if (str_comp("-s", argv[i]) == 0 || str_comp("--silent", argv[i]) == 0)
 			Silent = true;
-		}
-	}
 
 #if defined(CONF_PLATFORM_ANDROID)
 	InitAndroid();
@@ -4550,6 +4578,16 @@ int main(int argc, const char **argv)
 		}
 	}
 
+	prognm = argv[0];
+
+	fifoout.evnm = "FIFOOUT";
+	fifoin.evnm = "FIFOIN";
+
+	openfifo(&fifoout, "w");
+	openfifo(&fifoin, "r");
+
+	setvbuf(fifoin.f, 0, _IOLBF, 0);
+
 	// run the client
 	dbg_msg("client", "starting...");
 	pClient->Run();
diff --git a/src/engine/client/fifo.h b/src/engine/client/fifo.h
new file mode 100644
index 000000000..0f77a2ce0
--- /dev/null
+++ b/src/engine/client/fifo.h
@@ -0,0 +1,8 @@
+struct fifo {
+	FILE *f;
+	const char *evnm;
+	const char *fnm;
+};
+
+extern const char *prognm;
+extern struct fifo fifoout, fifoin;
diff --git a/src/engine/shared/config_variables.h b/src/engine/shared/config_variables.h
index d8fd9eee4..58500ce35 100644
--- a/src/engine/shared/config_variables.h
+++ b/src/engine/shared/config_variables.h
@@ -386,6 +386,15 @@ MACRO_CONFIG_COL(ClHookCollColorNoColl, cl_hook_coll_color_no_coll, 65407, CFGFL
 MACRO_CONFIG_COL(ClHookCollColorHookableColl, cl_hook_coll_color_hookable_coll, 6401973, CFGFLAG_CLIENT | CFGFLAG_SAVE, "Specifies the color of a hookline that hits hookable tiles.")
 MACRO_CONFIG_COL(ClHookCollColorTeeColl, cl_hook_coll_color_tee_coll, 2817919, CFGFLAG_CLIENT | CFGFLAG_SAVE, "Specifies the color of a hookline that hits tees.")
 
+/* for ai */
+MACRO_CONFIG_COL(ClFreezeCollColor, cl_freeze_coll_hkln_color, 9306015, CFGFLAG_CLIENT | CFGFLAG_SAVE, "Specifies the color of the freeze collision line.")
+MACRO_CONFIG_COL(ClHookableCollColor, cl_hookable_coll_hkln_color, 1179449, CFGFLAG_CLIENT | CFGFLAG_SAVE, "Specifies the color of the hookable collision line.")
+MACRO_CONFIG_INT(ClFreezeLnCollSize, cl_freezeln_coll_size, 5, 1, 30, CFGFLAG_CLIENT | CFGFLAG_SAVE, "Size of hook collision line")
+MACRO_CONFIG_INT(ClHookableLnCollSize, cl_hookableln_coll_size, 10, 1, 30, CFGFLAG_CLIENT | CFGFLAG_SAVE, "Size of hook collision line")
+MACRO_CONFIG_INT(ClFreezeLnCollAlpha, cl_freezeln_coll_alpha, 50, 0, 100, CFGFLAG_CLIENT | CFGFLAG_SAVE, "Alpha of hook collision line (0 invisible, 100 fully visible)")
+MACRO_CONFIG_INT(ClHookableLnCollAlpha, cl_hookableln_coll_alpha, 50, 0, 100, CFGFLAG_CLIENT | CFGFLAG_SAVE, "Alpha of hook collision line (0 invisible, 100 fully visible)")
+
+
 MACRO_CONFIG_INT(ClChatTeamColors, cl_chat_teamcolors, 0, 0, 1, CFGFLAG_CLIENT | CFGFLAG_SAVE, "Show names in chat in team colors")
 MACRO_CONFIG_INT(ClChatReset, cl_chat_reset, 1, 0, 1, CFGFLAG_CLIENT | CFGFLAG_SAVE, "Reset chat when pressing escape")
 MACRO_CONFIG_INT(ClChatOld, cl_chat_old, 0, 0, 1, CFGFLAG_CLIENT | CFGFLAG_SAVE, "Old chat style: No tee, no background");
diff --git a/src/game/client/area.cpp b/src/game/client/area.cpp
new file mode 100644
index 000000000..7dd480737
--- /dev/null
+++ b/src/game/client/area.cpp
@@ -0,0 +1,11 @@
+#include <base/do.h>
+#include <base/vmath.h>
+#include "area.h"
+
+int
+areahaspos(struct area *a, vec2 p)
+{
+	#define W(I, C) p.C >= a->c.C - a->d && p.C <= a->c.C + a->d
+	return do2e(W, &&);
+	#undef W
+}
diff --git a/src/game/client/area.h b/src/game/client/area.h
new file mode 100644
index 000000000..2dafaa4e6
--- /dev/null
+++ b/src/game/client/area.h
@@ -0,0 +1,7 @@
+/* square area */
+struct area {
+	vec2 c; /* center */
+	int d; /* dimension */
+};
+
+int areahaspos(struct area *a, vec2 p);
diff --git a/src/game/client/components/controls.cpp b/src/game/client/components/controls.cpp
index 05d26098e..d1c73f4e5 100644
--- a/src/game/client/components/controls.cpp
+++ b/src/game/client/components/controls.cpp
@@ -12,6 +12,7 @@
 #include <game/client/components/scoreboard.h>
 #include <game/client/gameclient.h>
 #include <game/collision.h>
+#include <engine/client/ai.h>
 
 #include <base/vmath.h>
 
@@ -367,6 +368,19 @@ int CControls::SnapInput(int *pData)
 			Send = true;
 	}
 
+	if (ai_gaveinp) {
+		m_InputData[g_Config.m_ClDummy] = ai_inp;
+		Send = true;
+		ai_gaveinp = 0;
+	} else {
+		ai_inp = m_InputData[g_Config.m_ClDummy];
+		Send = false;
+	}
+	if (ai_selfkill) {
+		GameClient()->SendKill(-1);
+		ai_selfkill = 0;
+	}
+
 	// copy and return size
 	m_LastData[g_Config.m_ClDummy] = m_InputData[g_Config.m_ClDummy];
 
diff --git a/src/game/client/components/hud.cpp b/src/game/client/components/hud.cpp
index 35e9522e5..c27ea182c 100644
--- a/src/game/client/components/hud.cpp
+++ b/src/game/client/components/hud.cpp
@@ -3,6 +3,7 @@
 #include <engine/graphics.h>
 #include <engine/shared/config.h>
 #include <engine/textrender.h>
+#include <engine/client/ai.h>
 
 #include <game/client/animstate.h>
 #include <game/client/components/scoreboard.h>
@@ -874,6 +875,7 @@ void CHud::RenderPlayerState(const int ClientID)
 		}
 		TotalJumpsToDisplay = maximum(minimum(abs(pCharacter->m_Jumps), 10), 0);
 		AvailableJumpsToDisplay = maximum(minimum(UnusedJumps, TotalJumpsToDisplay), 0);
+		ai_availjumps = AvailableJumpsToDisplay;
 	}
 	else
 	{
diff --git a/src/game/client/components/menus_settings.cpp b/src/game/client/components/menus_settings.cpp
index 87f30d452..54f6437a2 100644
--- a/src/game/client/components/menus_settings.cpp
+++ b/src/game/client/components/menus_settings.cpp
@@ -2399,6 +2399,21 @@ void CMenus::RenderSettingsHUD(CUIRect MainView)
 			Button.VSplitLeft(45.0f, &Label, &Button);
 			UI()->DoLabelScaled(&Label, Localize("Size"), 14.0f, TEXTALIGN_LEFT);
 			g_Config.m_ClHookCollSize = (int)(UIEx()->DoScrollbarH(&g_Config.m_ClHookCollSize, &Button, g_Config.m_ClHookCollSize / 20.0f) * 20.0f);
+			/* for ai line size */
+			MainView.HSplitTop(5.0f, &Button, &MainView);
+			MainView.HSplitTop(20.0f, &Button, &MainView);
+			Button.VSplitLeft(150.0f, &Label, &Button);
+			UI()->DoLabelScaled(&Label, Localize("FreezeLineS"), 14.0f, TEXTALIGN_LEFT);
+			g_Config.m_ClFreezeLnCollSize = (int)(UIEx()-> \
+				DoScrollbarH(&g_Config.m_ClFreezeLnCollSize, &Button, \
+				g_Config.m_ClFreezeLnCollSize / 30.0f) * 30.0f);
+			MainView.HSplitTop(5.0f, &Button, &MainView);
+			MainView.HSplitTop(20.0f, &Button, &MainView);
+			Button.VSplitLeft(150.0f, &Label, &Button);
+			UI()->DoLabelScaled(&Label, Localize("HookableLnSize"), 14.0f, TEXTALIGN_LEFT);
+			g_Config.m_ClHookableLnCollSize = (int)(UIEx()-> \
+				DoScrollbarH(&g_Config.m_ClHookableLnCollSize, &Button, \
+				g_Config.m_ClHookableLnCollSize / 30.0f) * 30.0f);
 		}
 
 		{
@@ -2408,6 +2423,21 @@ void CMenus::RenderSettingsHUD(CUIRect MainView)
 			Button.VSplitLeft(45.0f, &Label, &Button);
 			UI()->DoLabelScaled(&Label, Localize("Alpha"), 14.0f, TEXTALIGN_LEFT);
 			g_Config.m_ClHookCollAlpha = (int)(UIEx()->DoScrollbarH(&g_Config.m_ClHookCollAlpha, &Button, g_Config.m_ClHookCollAlpha / 100.0f) * 100.0f);
+			/* for ai line alpha */
+			MainView.HSplitTop(5.0f, &Button, &MainView);
+			MainView.HSplitTop(20.0f, &Button, &MainView);
+			Button.VSplitLeft(150.0f, &Label, &Button);
+			UI()->DoLabelScaled(&Label, Localize("FreezeLnAlpha"), 14.0f, TEXTALIGN_LEFT);
+			g_Config.m_ClFreezeLnCollAlpha = (int)(UIEx()-> \
+				DoScrollbarH(&g_Config.m_ClFreezeLnCollAlpha, &Button, \
+				g_Config.m_ClFreezeLnCollAlpha / 100.0f) * 100.0f);
+			MainView.HSplitTop(5.0f, &Button, &MainView);
+			MainView.HSplitTop(20.0f, &Button, &MainView);
+			Button.VSplitLeft(150.0f, &Label, &Button);
+			UI()->DoLabelScaled(&Label, Localize("HookableLnAlpha"), 14.0f, TEXTALIGN_LEFT);
+			g_Config.m_ClHookableLnCollAlpha = (int)(UIEx()-> \
+				DoScrollbarH(&g_Config.m_ClHookableLnCollAlpha, &Button, \
+				g_Config.m_ClHookableLnCollAlpha / 100.0f) * 100.0f);
 		}
 		MainView.HSplitTop(5.0f, 0x0, &MainView);
 		MainView.HSplitTop(25.0f, &SectionTwo, &MainView);
@@ -2424,6 +2454,11 @@ void CMenus::RenderSettingsHUD(CUIRect MainView)
 		MainView.HSplitTop(25.0f, &SectionTwo, &MainView);
 
 		DoLine_ColorPicker(&HookCollTeeCollResetID, 25.0f, 180.0f, 13.0f, 5.0f, &SectionTwo, Localize("Tee"), &g_Config.m_ClHookCollColorTeeColl, ColorRGBA(1.0f, 1.0f, 0.0f, 1.0f), false);
+
+		/* for ai */
+		static int FreezeCollColor, HookableCollColor;
+		DoLine_ColorPicker(&FreezeCollColor, 25.0f, 180.0f, 13.0f, 5.0f, &SectionTwo, Localize("FreezeHkLn"), &g_Config.m_ClFreezeCollColor, ColorRGBA(1.0f, 1.0f, 0.0f, 1.0f), false);
+		DoLine_ColorPicker(&HookableCollColor, 25.0f, 180.0f, 13.0f, 5.0f, &SectionTwo, Localize("HookableHkLn"), &g_Config.m_ClHookableCollColor, ColorRGBA(1.0f, 1.0f, 0.0f, 1.0f), false);
 	}
 	else if(s_CurTab == 1)
 	{ // ***** CHAT TAB ***** //
diff --git a/src/game/client/components/players.cpp b/src/game/client/components/players.cpp
index 99963d439..4481524c7 100644
--- a/src/game/client/components/players.cpp
+++ b/src/game/client/components/players.cpp
@@ -21,6 +21,12 @@
 
 #include <base/color.h>
 
+/* for ai */
+#include <engine/client/ai.h>
+#include <engine/client/graphics_threaded.h>
+#include <base/do.h>
+#include <base/util.h>
+
 void CPlayers::RenderHand(CTeeRenderInfo *pInfo, vec2 CenterPos, vec2 Dir, float AngleOffset, vec2 PostRotOffset, float Alpha)
 {
 	vec2 HandPos = CenterPos + Dir;
@@ -117,6 +123,32 @@ float CPlayers::GetPlayerTargetAngle(
 	}
 }
 
+/* for ai */
+
+intern void
+drawrect(IGraphics *gfx, FPARS(vec2, a, b), float w)
+{
+	vec2 p[4], n, d;
+
+	d = b - a;
+	n = normalize(vec2(d.y, -d.x));
+	p[0] = a + n * w;
+	p[1] = a - n * w;
+	p[2] = b + n * w;
+	p[3] = b - n * w;
+
+//	IGraphics::CFreeformItem FreeformItem(Pos0.x, Pos0.y, Pos1.x, Pos1.y, Pos2.x, Pos2.y, Pos3.x, Pos3.y);
+	/* when zogtib is having fun ðŸ¤¯ */
+	#define CM ,
+	#define CP(I, C, V) V.C
+	#define P(I, C) do2rv(CP,,, CM, p[I])
+	IGraphics::CFreeformItem ffi(do4r(P,,, CM));
+	#undef P
+	#undef CP
+	#undef CM
+	gfx->QuadsDrawFreeform(&ffi, 1);
+}
+
 void CPlayers::RenderHookCollLine(
 	const CNetObj_Character *pPrevChar,
 	const CNetObj_Character *pPlayerChar,
@@ -178,12 +210,17 @@ void CPlayers::RenderHookCollLine(
 			vec2 InitPos = Position;
 			vec2 FinishPos = InitPos + ExDirection * (m_pClient->m_Tuning[g_Config.m_ClDummy].m_HookLength - 42.0f);
 
-			if(g_Config.m_ClHookCollSize > 0)
-				Graphics()->QuadsBegin();
-			else
-				Graphics()->LinesBegin();
+			/* for ai */
+			Graphics()->QuadsBegin();
+//			if(g_Config.m_ClHookCollSize > 0 || g_Config.m_ClHookableLnCollSize > 0 || g_Config.m_ClHookableLnCollSize > 0)
+//				Graphics()->QuadsBegin();
+//			else
+//				Graphics()->LinesBegin();
 
 			ColorRGBA HookCollColor = color_cast<ColorRGBA>(ColorHSLA(g_Config.m_ClHookCollColorNoColl));
+			/* for ai */
+			ColorRGBA FreezeCollColor = color_cast<ColorRGBA>(ColorHSLA(g_Config.m_ClFreezeCollColor));
+			ColorRGBA HookableCollColor = color_cast<ColorRGBA>(ColorHSLA(g_Config.m_ClHookableCollColor));
 
 			vec2 OldPos = InitPos + ExDirection * CCharacterCore::PhysicalSize() * 1.5f;
 			vec2 NewPos = OldPos;
@@ -237,28 +274,52 @@ void CPlayers::RenderHookCollLine(
 				// invert the hook coll colors when using cl_show_hook_coll_always and +showhookcoll is pressed
 				HookCollColor = color_invert(HookCollColor);
 			}
-			Graphics()->SetColor(HookCollColor.WithAlpha(Alpha));
-			if(g_Config.m_ClHookCollSize > 0)
 			{
+				/* for ai */
+				vec2 e, c, p = Position;
+				float a, HkblAlpha, FrzAlpha;
+				int i;
+
+				HkblAlpha = FrzAlpha = 1;
+
+				FreezeCollColor = color_cast<ColorRGBA>(ColorHSLA(g_Config.m_ClFreezeCollColor));
+				HookableCollColor = color_cast<ColorRGBA>(ColorHSLA(g_Config.m_ClHookableCollColor));
+				HkblAlpha *= (float)g_Config.m_ClHookableLnCollAlpha / 100;
+				FrzAlpha *= (float)g_Config.m_ClFreezeLnCollAlpha / 100;
+				
+				Graphics()->SetColor(HookableCollColor.WithAlpha(HkblAlpha));
+				for (i = 0; i < ai_NRAYS; i++) {
+					float sc, width;
+
+					sc = ai_htds[i] >= 0 ? ai_htds[i] : 1;
+
+					a = i * 2*pi / ai_NRAYS;
+					e = p + vec2(cosf(a), sinf(a)) * (sc * ai_RAYLEN);
+					width = 0.5f + (float)(g_Config.m_ClHookableLnCollSize - 1) * 0.25f;
+					drawrect(Graphics(), p, e, width);
+				}
+
+				Graphics()->SetColor(FreezeCollColor.WithAlpha(FrzAlpha));
+				for (i = 0; i < ai_NRAYS; i++) {
+					float sc, width;
+
+					sc = ai_htds[i] >= 0 ? ai_htds[i] : 1;
+
+					a = i * 2*pi / ai_NRAYS;
+					e = p + vec2(cosf(a), sinf(a)) * (sc * ai_RAYLEN);
+					width = 0.5f + (float)(g_Config.m_ClFreezeLnCollSize - 1) * 0.25f;
+					drawrect(Graphics(), p, e, width);
+				}
+
+				Graphics()->SetColor(HookCollColor.WithAlpha(Alpha));
 				float LineWidth = 0.5f + (float)(g_Config.m_ClHookCollSize - 1) * 0.25f;
-				vec2 PerpToAngle = normalize(vec2(ExDirection.y, -ExDirection.x)) * GameClient()->m_Camera.m_Zoom;
-				vec2 Pos0 = FinishPos + PerpToAngle * -LineWidth;
-				vec2 Pos1 = FinishPos + PerpToAngle * LineWidth;
-				vec2 Pos2 = InitPos + PerpToAngle * -LineWidth;
-				vec2 Pos3 = InitPos + PerpToAngle * LineWidth;
-				IGraphics::CFreeformItem FreeformItem(Pos0.x, Pos0.y, Pos1.x, Pos1.y, Pos2.x, Pos2.y, Pos3.x, Pos3.y);
-				Graphics()->QuadsDrawFreeform(&FreeformItem, 1);
-				Graphics()->QuadsEnd();
-			}
-			else
-			{
-				IGraphics::CLineItem LineItem(InitPos.x, InitPos.y, FinishPos.x, FinishPos.y);
-				Graphics()->LinesDraw(&LineItem, 1);
-				Graphics()->LinesEnd();
+				drawrect(Graphics(), InitPos, FinishPos, LineWidth);
 			}
+		Graphics()->QuadsEnd();
 		}
 	}
 }
+
 void CPlayers::RenderHook(
 	const CNetObj_Character *pPrevChar,
 	const CNetObj_Character *pPlayerChar,
diff --git a/src/game/client/gameclient.cpp b/src/game/client/gameclient.cpp
index d6c801442..5b616aac9 100644
--- a/src/game/client/gameclient.cpp
+++ b/src/game/client/gameclient.cpp
@@ -30,6 +30,7 @@
 #include "render.h"
 #include <game/localization.h>
 #include <game/version.h>
+#include <engine/client/ai.h>
 
 #include "gameclient.h"
 
@@ -1225,7 +1226,7 @@ void CGameClient::OnNewSnapshot()
 
 					if(pInfo->m_Local)
 					{
-						m_Snap.m_LocalClientID = Item.m_ID;
+						ai_CID = m_Snap.m_LocalClientID = Item.m_ID;
 						m_Snap.m_pLocalInfo = pInfo;
 
 						if(pInfo->m_Team == TEAM_SPECTATORS)
diff --git a/src/game/client/prediction/entities/character.cpp b/src/game/client/prediction/entities/character.cpp
index 54e739bdc..9b605a3ab 100644
--- a/src/game/client/prediction/entities/character.cpp
+++ b/src/game/client/prediction/entities/character.cpp
@@ -3,6 +3,21 @@
 #include <engine/shared/config.h>
 #include <game/generated/client_data.h>
 #include <game/mapitems.h>
+#include <game/client/gameclient.h>
+
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <poll.h>
+
+//for ai
+#include <engine/client/ai.h>
+#include <engine/client/fifo.h>
+#include <base/util.h>
+#include <base/cycbuf.h>
+#include <game/client/area.h>
+#include <base/math.h>
+#include <engine/client/ai.h>
 
 #include "character.h"
 #include "laser.h"
@@ -10,6 +25,52 @@
 
 // Character, "physical" player's part
 
+#define V2F "%d %d"
+#define V2A(V) (int)(V).x, (int)(V).y
+
+intern struct area prevareabuf[32];
+intern struct area curarea;
+intern struct cycbuf prevareas;
+
+bool ColSF(CCollision *pCollision, vec2 Prev, vec2 Pos, int TILE) {
+//	CCollision *pCollision = pClient->Collision();
+	std::list<int> Indices = pCollision->GetMapIndices(Prev, Pos);
+	if(!Indices.empty())
+		for(int &Indice : Indices)
+		{
+			if(pCollision->GetTileIndex(Indice) == TILE)
+				return true;
+			if(pCollision->GetFTileIndex(Indice) == TILE)
+				return true;
+		}
+	else
+	{
+		if(pCollision->GetTileIndex(pCollision->GetPureMapIndex(Pos)) == TILE)
+			return true;
+		if(pCollision->GetFTileIndex(pCollision->GetPureMapIndex(Pos)) == TILE)
+			return true;
+	}
+	return false;
+}
+
+intern void
+gettiledist(float ds[], size_t nd, CCollision *cln, vec2 p, int tile)
+{
+	vec2 e, cp;
+	float a;
+	size_t i;
+	int t;
+
+	for (i = 0; i < nd; i++) {
+		a = i * 2*pi / nd;
+		e = vec2(cosf(a), sinf(a)) * ai_RAYLEN;
+		if ((t = cln->IntersectLineAllTiles(p, p + e, &cp, 0)) && t == tile)
+			ds[i] = length(cp - p) / ai_RAYLEN;
+		else
+			ds[i] = -1.f;
+	}
+}
+
 void CCharacter::SetWeapon(int W)
 {
 	if(W == m_Core.m_ActiveWeapon)
@@ -553,13 +614,156 @@ void CCharacter::ResetInput()
 	m_LatestPrevInput = m_LatestInput = m_Input;
 }
 
+intern int
+ckareas(struct area *cur, struct cycbuf *prev, vec2 p)
+{
+	#define new new_ /* zogtib big troll */
+	struct area *a, new;
+	size_t i;
+
+	#define ARF V2F " %d"
+	#define ARA(A) V2A((A).c), (A).d
+
+//	printf("p:" V2F " -- " ARF, V2A(p), ARA(*cur));
+	new = *cur;
+	if (p.x < cur->c.x - cur->d)
+		new.c.x -= 2 * cur->d;
+	else if (p.x > cur->c.x + cur->d)
+		new.c.x += 2 * cur->d;
+	else if (p.y < cur->c.y - cur->d)
+		new.c.y -= 2 * cur->d;
+	else if (p.y > cur->c.y + cur->d)
+		new.c.y += 2 * cur->d;
+	else {
+//		printf(" in\n");
+		return 0;
+	}
+
+//	printf("\n");
+	for (i = 1; i <= prev->nea; i++) {
+		a = (struct area *)cbelmat(prev, prev->fp + prev->nea - i);
+//		printf("pa[%d]: " ARF "\n", (int)i, ARA(*a));
+		if (areahaspos(a, p))
+			goto cut;
+	}
+//	printf("got to new area\n");
+	cbadd(prev, cur);
+	*cur = new;
+	return 1;
+cut:
+//	printf("move your a**\n");
+	prev->nea -= i;
+	*cur = *a;
+	return -(int)i;
+	#undef new
+}
+
 void CCharacter::Tick()
 {
+	static int haveread = 2;
+	struct pollfd pfd;
+	char inp[1024], *s;
+
+//	printf("m_ID: %d, ai_CID: %d\n", m_ID, ai_CID);
+	if (m_ID == ai_CID) {
+		int sk;
+		pfd.fd = fileno(fifoin.f);
+		pfd.events = POLLIN;
+//		ai_selfkill = 0;
+	ckinput:
+		switch (poll(&pfd, 1, 0)) {
+		case 1:
+			if (fgets(inp, sizeof inp, fifoin.f)) {
+//				printf("inp: %s\n", inp);
+				if ((s = strchr(inp, '\n')))
+					*s = 0;
+				sscanf(inp, "%d %d %d %d %d %d",
+					&ai_inp.m_Direction,
+					&ai_inp.m_TargetX,
+					&ai_inp.m_TargetY,
+					&ai_inp.m_Jump,
+					&ai_inp.m_Hook,
+					&sk);
+//					&ai_isdone);
+				ai_selfkill |= sk;
+	//			printf("%d %d %d\n",
+	//			ai_inp.m_Direction, ai_inp.m_TargetX, ai_inp.m_TargetY);
+				ai_gaveinp = 1;
+				haveread = 2;
+//				printf("haveread = 2\n");
+				goto ckinput;
+			}
+			break;
+		case 0:
+			if (haveread < 2)
+				haveread = 0;
+			break;
+		case -1:
+			perrn("poll: %s", fifoin.fnm);
+		}
+	}
+
+//	printf("haveread: %d\n", haveread);
+
 	DDRaceTick();
 
 	m_Core.m_Input = m_Input;
 	m_Core.Tick(true);
 
+	if (m_ID == ai_CID) {
+		static struct {
+			int freeze;
+			int start;
+			int finish;
+			int selfkill;
+			int area;
+			int ckpnt;
+		} rwd;
+
+//		if (!areahaspos(&curarea, m_Core.m_Pos) && !curarea.c.x && !curarea.c.y)
+		int i;
+		if ((i = ckareas(&curarea, &prevareas, m_Core.m_Pos)) < 0)
+			rwd.area = i;
+		else if (i > 0)
+			rwd.area = 1;
+		else
+			rwd.area = 0;
+
+		gettiledist(ai_htds, NELM(ai_htds), Collision(), m_Core.m_Pos, TILE_SOLID);
+		gettiledist(ai_ftds, NELM(ai_ftds), Collision(), m_Core.m_Pos, TILE_FREEZE);
+
+		if (haveread) {
+			rwd.freeze = (ColSF(Collision(), m_PrevPos, m_Core.m_Pos, TILE_FREEZE)) ? 1 : 0;
+			rwd.start = (ColSF(Collision(), m_PrevPos, m_Core.m_Pos, TILE_START)) ? 1 : 0;
+			rwd.finish = (ColSF(Collision(), m_PrevPos, m_Core.m_Pos, TILE_FINISH)) ? 1 : 0;
+			rwd.selfkill = ai_selfkill ? 1 : 0;
+			int ckpnt;
+			for (ckpnt = TILE_CHECKPOINT_FIRST; ckpnt < TILE_CHECKPOINT_LAST; ckpnt++)
+				rwd.ckpnt = (ColSF(Collision(), m_PrevPos, m_Core.m_Pos, ckpnt)) ? 1 : 0;
+
+			fprintf(fifoout.f, V2F " " V2F " " V2F " %d %d %d" " %d %d %d %d" " %d",
+				V2A(m_Core.m_Pos), V2A(m_Core.m_Vel), V2A(m_Core.m_HookPos),
+				m_Core.m_HookState, m_Core.m_Direction, ai_availjumps,
+				rwd.freeze, rwd.start, rwd.finish, rwd.area,
+				rwd.ckpnt);
+			size_t idx;
+			for (idx = 0; idx < NELM(ai_htds); idx++) {
+				fprintf(fifoout.f, " %f", ai_htds[idx]);
+			}
+			for (idx = 0; idx < NELM(ai_ftds); idx++) {
+				fprintf(fifoout.f, " %f", ai_ftds[idx]);
+			}
+			fprintf(fifoout.f, "\n");
+//			printf("cid: %d " V2F " " V2F " " V2F " %d %d %d" " %d %d %d\n",
+//				ai_CID,
+//				V2A(m_Core.m_Pos), V2A(m_Core.m_Vel), V2A(m_Core.m_HookPos),
+//				m_Core.m_HookState, m_Core.m_Direction, ai_availjumps,
+//				rwd.freeze, rwd.start, rwd.finish);
+			fflush(fifoout.f);
+			haveread = 0;
+		}
+	}
+
 	// handle Weapons
 	HandleWeapons();
 
@@ -1146,6 +1350,9 @@ CCharacter::CCharacter(CGameWorld *pGameWorld, int ID, CNetObj_Character *pChar,
 
 	m_LatestPrevInput = m_LatestInput = m_PrevInput = m_SavedInput = m_Input;
 
+	cbinit(&prevareas, sizeof(struct area), NELM(prevareabuf), prevareabuf);
+	curarea.d = 5 * 32;
+
 	ResetPrediction();
 	Read(pChar, pExtended, pExtendedDisplayInfo, false);
 }
@@ -1181,6 +1388,10 @@ void CCharacter::ResetPrediction()
 	}
 	m_LastWeaponSwitchTick = 0;
 	m_LastTuneZoneTick = 0;
+
+	/* for ai */
+	prevareas.nea = 0;
+	curarea.c = vec2{};
 }
 
 void CCharacter::Read(CNetObj_Character *pChar, CNetObj_DDNetCharacter *pExtended, CNetObj_DDNetCharacterDisplayInfo *pExtendedDisplayInfo, bool IsLocal)
diff --git a/src/game/collision.cpp b/src/game/collision.cpp
index cbf9d8070..b2ca62cd6 100644
--- a/src/game/collision.cpp
+++ b/src/game/collision.cpp
@@ -320,6 +320,32 @@ int CCollision::IntersectLine(vec2 Pos0, vec2 Pos1, vec2 *pOutCollision, vec2 *p
 	return 0;
 }
 
+int CCollision::IntersectLineAllTiles(vec2 Pos0, vec2 Pos1, vec2 *pOutCollision, vec2 *pOutBeforeCollision) const
+{
+	float Distance = distance(Pos0, Pos1);
+	int End(Distance + 1);
+	vec2 Pos, Last = Pos0;
+
+	for (int i = 0; i <= End; i++) {
+		Pos = mix(Pos0, Pos1, i / (float)End);
+
+		if (CheckPoint(Pos)) {
+			if (pOutCollision)
+				*pOutCollision = Pos;
+			if (pOutBeforeCollision)
+				*pOutBeforeCollision = Last;
+			return GetCollisionAt(Pos.x, Pos.y);
+		}
+
+		Last = Pos;
+	}
+	if (pOutCollision)
+		*pOutCollision = Pos1;
+	if (pOutBeforeCollision)
+		*pOutBeforeCollision = Pos1;
+	return 0;
+}
+
 int CCollision::IntersectLineTeleHook(vec2 Pos0, vec2 Pos1, vec2 *pOutCollision, vec2 *pOutBeforeCollision, int *pTeleNr) const
 {
 	float Distance = distance(Pos0, Pos1);
diff --git a/src/game/collision.h b/src/game/collision.h
index bd1743e33..cde97082d 100644
--- a/src/game/collision.h
+++ b/src/game/collision.h
@@ -39,6 +39,7 @@ public:
 	int GetWidth() const { return m_Width; }
 	int GetHeight() const { return m_Height; }
 	int IntersectLine(vec2 Pos0, vec2 Pos1, vec2 *pOutCollision, vec2 *pOutBeforeCollision) const;
+	int IntersectLineAllTiles(vec2 Pos0, vec2 Pos1, vec2 *pOutCollision, vec2 *pOutBeforeCollision) const;
 	int IntersectLineTeleWeapon(vec2 Pos0, vec2 Pos1, vec2 *pOutCollision, vec2 *pOutBeforeCollision, int *pTeleNr) const;
 	int IntersectLineTeleHook(vec2 Pos0, vec2 Pos1, vec2 *pOutCollision, vec2 *pOutBeforeCollision, int *pTeleNr) const;
 	void MovePoint(vec2 *pInoutPos, vec2 *pInoutVel, float Elasticity, int *pBounces) const;
diff --git a/src/game/gamecore.cpp b/src/game/gamecore.cpp
index 30b738c85..1369ff16b 100644
--- a/src/game/gamecore.cpp
+++ b/src/game/gamecore.cpp
@@ -110,7 +110,7 @@ void CCharacterCore::Reset()
 
 	// never initialize both to 0
 	m_Input.m_TargetX = 0;
-	m_Input.m_TargetY = -1;
+	m_Input.m_TargetY = -100;
 }
 
 void CCharacterCore::Tick(bool UseInput)
diff --git a/src/game/server/gamecontroller.cpp b/src/game/server/gamecontroller.cpp
index 1f8c316ac..b01575171 100644
--- a/src/game/server/gamecontroller.cpp
+++ b/src/game/server/gamecontroller.cpp
@@ -97,6 +97,7 @@ void IGameController::DoActivityCheck()
 
 float IGameController::EvaluateSpawnPos(CSpawnEval *pEval, vec2 Pos, int DDTeam)
 {
+	return rand();
 	float Score = 0.0f;
 	CCharacter *pC = static_cast<CCharacter *>(GameServer()->m_World.FindFirst(CGameWorld::ENTTYPE_CHARACTER));
 	for(; pC; pC = (CCharacter *)pC->TypeNext())
diff --git a/src/game/server/teams.cpp b/src/game/server/teams.cpp
index 96b2c352b..cab506b35 100644
--- a/src/game/server/teams.cpp
+++ b/src/game/server/teams.cpp
@@ -657,6 +657,7 @@ void CGameTeams::OnTeamFinish(CPlayer **Players, unsigned int Size, float Time,
 
 void CGameTeams::OnFinish(CPlayer *Player, float Time, const char *pTimestamp)
 {
+	return;
 	if(!Player || !Player->IsPlaying())
 		return;
 	// TODO:DDRace:btd: this ugly
diff --git a/src/tools/map_diff.cpp b/src/tools/map_diff.cpp
index 07dab55e0..da0358210 100644
--- a/src/tools/map_diff.cpp
+++ b/src/tools/map_diff.cpp
@@ -5,93 +5,59 @@
 #include <game/gamecore.h>
 #include <game/mapitems.h>
 
-bool Process(IStorage *pStorage, const char **pMapNames)
+#include <pnglite.h>
+
+#define eprintf(...) fprintf(stderr, __VA_ARGS__);
+
+bool Process(IStorage *pStorage, const char *mapfnm)
 {
-	CDataFileReader Maps[2];
-
-	for(int i = 0; i < 2; ++i)
-	{
-		if(!Maps[i].Open(pStorage, pMapNames[i], IStorage::TYPE_ABSOLUTE))
-		{
-			dbg_msg("map_compare", "error opening map '%s'", pMapNames[i]);
-			return false;
-		}
+	CDataFileReader Map;
 
-		CDataFileReader *pMap = &Maps[i];
-		// check version
-		CMapItemVersion *pVersion = (CMapItemVersion *)pMap->FindItem(MAPITEMTYPE_VERSION, 0);
-		if(pVersion && pVersion->m_Version != 1)
-			return false;
+	if (!Map.Open(pStorage, mapfnm, IStorage::TYPE_ABSOLUTE)) {
+		fprintf(stderr, "error opening map '%s'", mapfnm);
+		return false;
 	}
 
-	int Start[2], Num[2];
+	// check version
+	CMapItemVersion *pVersion = (CMapItemVersion *)Map.FindItem(MAPITEMTYPE_VERSION, 0);
+	if (pVersion && pVersion->m_Version != 1)
+		return false;
 
-	Maps[0].GetType(MAPITEMTYPE_LAYER, &Start[0], &Num[0]);
-	Maps[1].GetType(MAPITEMTYPE_LAYER, &Start[1], &Num[1]);
+	int Start, Num;
 
-	// ensure basic layout
-	if(Num[0] != Num[1])
-	{
-		dbg_msg("map_compare", "different layer numbers:");
-		for(int i = 0; i < 2; ++i)
-			dbg_msg("map_compare", "  \"%s\": %d layers", pMapNames[i], Num[i]);
-		return false;
-	}
+	Map.GetType(MAPITEMTYPE_LAYER, &Start, &Num);
 
-	// preload data
-	for(int j = 0; j < Num[0]; ++j)
-	{
-		CMapItemLayer *pItem[2];
-		CMapItemLayerTilemap *pTilemap[2];
-		for(int i = 0; i < 2; ++i)
-		{
-			pItem[i] = (CMapItemLayer *)Maps[i].GetItem(Start[i] + j, 0, 0);
-			pTilemap[i] = (CMapItemLayerTilemap *)pItem[i];
-			(void)(CTile *) Maps[i].GetData(pTilemap[i]->m_Data);
-		}
-	}
+	for (int j = 0; j < Num; ++j) {
+		CMapItemLayer *pItem;
+		CMapItemLayerTilemap *pTilemap;
+		CTile *pTile;
+		char aName[16];
 
-	// compare
-	for(int j = 0; j < Num[0]; ++j)
-	{
-		CMapItemLayer *pItem[2];
-		for(int i = 0; i < 2; ++i)
-			pItem[i] = (CMapItemLayer *)Maps[i].GetItem(Start[i] + j, 0, 0);
+		pItem = (CMapItemLayer *)Map.GetItem(Start + j, 0, 0);
+		pTilemap = (CMapItemLayerTilemap *)pItem;
+		if (!(pTilemap->m_Flags & TILESLAYERFLAG_GAME))
+			continue;
+		Map.GetData(pTilemap->m_Data);
 
-		if(pItem[0]->m_Type != LAYERTYPE_TILES)
+		if (pItem->m_Type != LAYERTYPE_TILES)
 			continue;
 
-		CMapItemLayerTilemap *pTilemap[2];
-		char aName[2][16];
+		IntsToStr(pTilemap->m_aName, sizeof(pTilemap->m_aName) / sizeof(int), aName);
 
-		for(int i = 0; i < 2; ++i)
-		{
-			pTilemap[i] = (CMapItemLayerTilemap *)pItem[i];
-			IntsToStr(pTilemap[i]->m_aName, sizeof(pTilemap[i]->m_aName) / sizeof(int), aName[i]);
-		}
+		pTile = (CTile *)Map.GetData(pTilemap->m_Data);
 
-		if(str_comp(aName[0], aName[1]) != 0 || pTilemap[0]->m_Width != pTilemap[1]->m_Width || pTilemap[0]->m_Height != pTilemap[1]->m_Height)
-		{
-			dbg_msg("map_compare", "different tile layers:");
-			for(int i = 0; i < 2; ++i)
-				dbg_msg("map_compare", "  \"%s\" (%dx%d)", aName[i], pTilemap[i]->m_Width, pTilemap[i]->m_Height);
-			return false;
-		}
-		CTile *pTile[2];
-		for(int i = 0; i < 2; ++i)
-			pTile[i] = (CTile *)Maps[i].GetData(pTilemap[i]->m_Data);
-
-		for(int y = 0; y < pTilemap[0]->m_Height; y++)
-		{
-			for(int x = 0; x < pTilemap[0]->m_Width; x++)
-			{
-				int pos = y * pTilemap[0]->m_Width + x;
-				if(pTile[0][pos].m_Index != pTile[1][pos].m_Index || pTile[0][pos].m_Flags != pTile[1][pos].m_Flags)
-				{
-					dbg_msg("map_compare", "[%d:%s] %dx%d: (index: %d, flags: %d) != (index: %d, flags: %d)", Num[0], aName[0], x, y, pTile[0][pos].m_Index, pTile[0][pos].m_Flags, pTile[1][pos].m_Index, pTile[0][pos].m_Flags);
-				}
+		int x, y, pos;
+		printf("%d %d\n", pTilemap->m_Width, pTilemap->m_Height);
+		for (y = 0; y < pTilemap->m_Height; y++) {
+			for (x = 0; x < pTilemap->m_Width; x++) {
+				pos = y * pTilemap->m_Width + x;
+//				printf("[%d:%s] %dx%d: (idx: %d, flgs: %d)\n", j, aName,
+//				printf("%d %d %d\n", x, y, pTile[pos].m_Index);
+				printf(&" %d"[!x], pTile[pos].m_Index);
 			}
+			printf("\n");
 		}
+		break;
 	}
 
 	return true;
@@ -103,20 +69,17 @@ int main(int argc, const char *argv[])
 	std::vector<std::shared_ptr<ILogger>> apLoggers;
 	apLoggers.push_back(std::shared_ptr<ILogger>(log_logger_stdout()));
 	IOHANDLE LogFile = io_open("map_diff.txt", IOFLAG_WRITE);
-	if(LogFile)
-	{
+
+	if (LogFile)
 		apLoggers.push_back(std::shared_ptr<ILogger>(log_logger_file(LogFile)));
-	}
 	log_set_global_logger(log_logger_collection(std::move(apLoggers)).release());
 
 	IStorage *pStorage = CreateLocalStorage();
 
-	if(argc != 3)
-	{
-		dbg_msg("usage", "%s map1 map2", argv[0]);
+	if (argc != 2) {
+		eprintf("usage: %s map\n", argv[0]);
 		return -1;
 	}
-	int Result = Process(pStorage, &argv[1]) ? 0 : 1;
-	cmdline_free(argc, argv);
-	return Result;
+
+	return Process(pStorage, argv[1]);
 }
