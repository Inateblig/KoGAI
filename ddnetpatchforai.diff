diff --git a/CMakeLists.txt b/CMakeLists.txt
index 38dae4940..f23782687 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1674,6 +1674,12 @@ add_custom_command(OUTPUT "src/game/generated/wordlist.h"
 
 # Sources
 set_src(BASE GLOB_RECURSE src/base
+  #For ai
+  cycbuf.cpp
+  cycbuf.h
+  util.h
+  do.h
+
   color.h
   detect.h
   dynamic.h
@@ -1971,6 +1977,10 @@ if(CLIENT)
     video.h
   )
   set_src(GAME_CLIENT GLOB_RECURSE src/game/client
+    #For ai
+    area.cpp
+    area.h
+
     animstate.cpp
     animstate.h
     component.cpp
diff --git a/src/base/cycbuf.cpp b/src/base/cycbuf.cpp
new file mode 100644
index 000000000..f79df5433
--- /dev/null
+++ b/src/base/cycbuf.cpp
@@ -0,0 +1,39 @@
+#include <string.h>
+
+#include "util.h"
+#include "cycbuf.h"
+
+void
+cbinit(struct cycbuf *cb, FPARS(size_t, elsz, nelm), void *buf)
+{
+	cb->elsz = elsz;
+	cb->nelm = nelm;
+	cb->nea = cb->fp = 0;
+	cb->buf = buf;
+}
+
+void
+cbadd(struct cycbuf *cb, void *elp)
+{
+	memcpy(cbelmat(cb, cb->fp + cb->nea), elp, cb->elsz);
+
+	if (cb->nea < cb->nelm)
+		cb->nea++;
+	else
+		cb->fp++;
+}
+
+void *
+cbget(struct cycbuf *cb)
+{
+	if (!cb->nea)
+		return 0;
+	cb->nea--;
+	return cbelmat(cb, cb->fp++);
+}
+
+void *
+cbelmat(struct cycbuf *cb, size_t idx)
+{
+	return (char *)cb->buf + idx % cb->nelm * cb->elsz;
+}
diff --git a/src/base/cycbuf.h b/src/base/cycbuf.h
new file mode 100644
index 000000000..db9004744
--- /dev/null
+++ b/src/base/cycbuf.h
@@ -0,0 +1,11 @@
+struct cycbuf {
+	size_t elsz;
+	size_t nelm;
+	size_t nea, fp;
+	void *buf;
+};
+
+void cbinit(struct cycbuf *cb, FPARS(size_t, elsz, nelm), void *buf);
+void cbadd(struct cycbuf *cb, void *elp);
+void *cbget(struct cycbuf *cb);
+void *cbelmat(struct cycbuf *cb, size_t idx);
diff --git a/src/base/do.h b/src/base/do.h
new file mode 100644
index 000000000..0e81b05d4
--- /dev/null
+++ b/src/base/do.h
@@ -0,0 +1,103 @@
+/* do.h */
+
+#define do2r(W, B, A, J)\
+	B W(0, x) A J\
+	B W(1, y) A
+
+#define do2(W)\
+	do {\
+		W(0, x)\
+		W(1, y)\
+	} while (0)
+
+#define do2e(E, J)\
+	(\
+		(E(0, x)) J\
+		(E(1, y))\
+	)
+
+#define do2xz(W)\
+	do {\
+		W(0, x)\
+		W(2, z)\
+	} while (0)
+
+#define do2ryx(W, B, A, J)\
+	B W(1, y) A J\
+	B W(0, x) A
+
+#define do3r(W, B, A, J)\
+	B W(0, x) A J\
+	B W(1, y) A J\
+	B W(2, z) A
+#define do3rv(W, B, A, J, ...)\
+	B W(0, x, __VA_ARGS__) A J\
+	B W(1, y, __VA_ARGS__) A J\
+	B W(2, z, __VA_ARGS__) A
+
+#define do3(W)\
+	do {\
+		W(0, x)\
+		W(1, y)\
+		W(2, z)\
+	} while (0)
+#define do3v(W, ...)\
+	do {\
+		W(0, x, __VA_ARGS__)\
+		W(1, y, __VA_ARGS__)\
+		W(2, z, __VA_ARGS__)\
+	} while (0)
+
+#define do3e(E, J)\
+	(\
+		(E(0, x)) J\
+		(E(1, y)) J\
+		(E(2, z))\
+	)
+#define do3ev(E, J, ...)\
+	(\
+		(E(0, x, __VA_ARGS__)) J\
+		(E(1, y, __VA_ARGS__)) J\
+		(E(2, z, __VA_ARGS__))\
+	)
+
+#define do4(W)\
+	do {\
+		W(0, x)\
+		W(1, y)\
+		W(2, z)\
+		W(3, w)\
+	} while (0)
+#define do4v(W, ...)\
+	do {\
+		W(0, x, __VA_ARGS__)\
+		W(1, y, __VA_ARGS__)\
+		W(2, z, __VA_ARGS__)\
+		W(3, w, __VA_ARGS__)\
+	} while (0)
+
+#define do4r(W, B, A, J)\
+	B W(0, x) A J\
+	B W(1, y) A J\
+	B W(2, z) A J\
+	B W(3, w) A
+#define do4rv(W, B, A, J, ...)\
+	B W(0, x, __VA_ARGS__) A J\
+	B W(1, y, __VA_ARGS__) A J\
+	B W(2, z, __VA_ARGS__) A J\
+	B W(3, w, __VA_ARGS__) A
+
+#define do4e(E, J)\
+	(\
+		(E(0, x)) J\
+		(E(1, y)) J\
+		(E(2, z)) J\
+		(E(3, w))\
+	)
+#define do4ev(E, J, ...)\
+	(\
+		(E(0, x, __VA_ARGS__)) J\
+		(E(1, y, __VA_ARGS__)) J\
+		(E(2, z, __VA_ARGS__)) J\
+		(E(3, w, __VA_ARGS__))\
+	)
diff --git a/src/base/util.h b/src/base/util.h
new file mode 100644
index 000000000..f5eec5381
--- /dev/null
+++ b/src/base/util.h
@@ -0,0 +1,78 @@
+#define NELM(X) (sizeof (X) / sizeof (X)[0])
+
+#define eprintf(...) fprintf(stderr, __VA_ARGS__)
+
+extern const char *prognm;
+#if DBG
+//	#define perrpref()
+//		eprintf("%s: %s[%d]:%s: ", prognm, __FILE__, __LINE__, __func__)
+	#define perrpref() do {} while (0)
+	#define dbgf(...) perrf(__VA_ARGS__)
+#else
+	#define perrpref() eprintf("%s: ", prognm)
+	#define dbgf(...) 0
+#endif
+
+
+#define perrnand(DOWHAT, ...)\
+	do {\
+		perrpref();\
+		eprintf(__VA_ARGS__);\
+		eprintf(": %s\n", strerror(errno));\
+		DOWHAT;\
+	} while (0)
+#define perrfand(DOWHAT, ...)\
+	do {\
+		perrpref();\
+		eprintf(__VA_ARGS__);\
+		eprintf("\n");\
+		DOWHAT;\
+	} while (0)
+
+#define perrn(...) perrnand(, __VA_ARGS__)
+#define perrf(...) perrfand(, __VA_ARGS__)
+#define ferrn(...) perrnand(exit(1), __VA_ARGS__)
+#define ferrf(...) perrfand(exit(1), __VA_ARGS__)
+
+#define MIN(X, Y) ((X) < (Y) ? X : (Y))
+#define MAX(X, Y) ((X) > (Y) ? X : (Y))
+#define CLAMP(X, A, B) ((X) < (A) ? A : (X) > (B) ? B : (X))
+
+#define RET(V)\
+	do {\
+		rv = (V);\
+		goto befret;\
+	} while (0)
+
+#define SWAP(A, B)\
+	do {\
+		char t_[sizeof A];\
+		memcpy(t_, &(A), sizeof t_);\
+		memcpy(&(A), &(B), sizeof t_);\
+		memcpy(&(B), t_, sizeof t_);\
+	} while (0)
+
+#define intern static
+
+#define PPCAT(A, B) A##B
+#define PPECAT(A, B) PPCAT(A, B)
+#define PPARG8(_0, _1, _2, _3, _4, _5, _6, _7, _8, ...) _8
+#define PPNARGS(...) PPARG8(__VA_ARGS__, 8, 7, 6, 5, 4, 3, 2, 1)
+
+#define FPARS(T, ...)\
+	PPECAT(FPARS, PPNARGS(__VA_ARGS__))(T, __VA_ARGS__)
+
+#define FPARS2(T, A, B)\
+	T A, T B
+#define FPARS3(T, A, B, C)\
+	T A, T B, T C
+#define FPARS4(T, A, B, C, D)\
+	T A, T B, T C, T D
+#define FPARS5(T, A, B, C, D, E)\
+	T A, T B, T C, T D, T E
+#define FPARS6(T, A, B, C, D, E, F)\
+	T A, T B, T C, T D, T E, T F
+#define FPARS7(T, A, B, C, D, E, F, G)\
+	T A, T B, T C, T D, T E, T F, T G
+#define FPARS8(T, A, B, C, D, E, F, G, H)\
+	T A, T B, T C, T D, T E, T F, T G, T H
diff --git a/src/engine/client/ai.h b/src/engine/client/ai.h
new file mode 100644
index 000000000..31ed92202
--- /dev/null
+++ b/src/engine/client/ai.h
@@ -0,0 +1,7 @@
+#include <game/generated/protocol.h>
+extern CNetObj_PlayerInput ai_inp;
+extern int ai_gaveinp;
+extern int ai_selfkill;
+extern int ai_availjumps;
+extern int ai_isdone;
+extern int ai_CID;
diff --git a/src/engine/client/client.cpp b/src/engine/client/client.cpp
index 6c8ecce98..f49e66932 100644
--- a/src/engine/client/client.cpp
+++ b/src/engine/client/client.cpp
@@ -66,6 +66,30 @@
 #include "video.h"
 #endif
 
+#include <sys/stat.h>
+#include <base/util.h>
+#include "fifo.h"
+
+CNetObj_PlayerInput ai_inp;
+int ai_gaveinp;
+int ai_selfkill;
+int ai_availjumps;
+int ai_isdone;
+int ai_CID = -1;
+
+void openfifo(struct fifo *f, const char *mode) {
+	struct stat st;
+
+	if (!(f->fnm = getenv(f->evnm)))
+		ferrf("%s env variable is unset", f->evnm);
+	if (stat(f->fnm, &st))
+		ferrn("stat: %s", f->fnm);
+	if ((st.st_mode & S_IFMT) != S_IFIFO)
+		ferrf("%s: not a fifo file", f->fnm);
+	if (!(f->f = fopen(f->fnm, mode)))
+		ferrn("fopen: %s", f->fnm);
+}
+
 #include "SDL.h"
 #ifdef main
 #undef main
@@ -81,6 +105,9 @@
 #include <chrono>
 #include <thread>
 
+const char *prognm;
+struct fifo fifoout, fifoin;
+
 using namespace std::chrono_literals;
 
 static const ColorRGBA ClientNetworkPrintColor{0.7f, 1, 0.7f, 1.0f};
@@ -4370,13 +4397,9 @@ int main(int argc, const char **argv)
 	bool Silent = false;
 	bool RandInitFailed = false;
 
-	for(int i = 1; i < argc; i++)
-	{
-		if(str_comp("-s", argv[i]) == 0 || str_comp("--silent", argv[i]) == 0)
-		{
+	for (int i = 1; i < argc; i++)
+		if (str_comp("-s", argv[i]) == 0 || str_comp("--silent", argv[i]) == 0)
 			Silent = true;
-		}
-	}
 
 #if defined(CONF_PLATFORM_ANDROID)
 	InitAndroid();
@@ -4550,6 +4573,16 @@ int main(int argc, const char **argv)
 		}
 	}
 
+	prognm = argv[0];
+
+	fifoout.evnm = "FIFOOUT";
+	fifoin.evnm = "FIFOIN";
+
+	openfifo(&fifoout, "w");
+	openfifo(&fifoin, "r");
+
+	setvbuf(fifoin.f, 0, _IOLBF, 0);
+
 	// run the client
 	dbg_msg("client", "starting...");
 	pClient->Run();
diff --git a/src/engine/client/fifo.h b/src/engine/client/fifo.h
new file mode 100644
index 000000000..0f77a2ce0
--- /dev/null
+++ b/src/engine/client/fifo.h
@@ -0,0 +1,8 @@
+struct fifo {
+	FILE *f;
+	const char *evnm;
+	const char *fnm;
+};
+
+extern const char *prognm;
+extern struct fifo fifoout, fifoin;
diff --git a/src/game/client/area.cpp b/src/game/client/area.cpp
new file mode 100644
index 000000000..7dd480737
--- /dev/null
+++ b/src/game/client/area.cpp
@@ -0,0 +1,11 @@
+#include <base/do.h>
+#include <base/vmath.h>
+#include "area.h"
+
+int
+areahaspos(struct area *a, vec2 p)
+{
+	#define W(I, C) p.C >= a->c.C - a->d && p.C <= a->c.C + a->d
+	return do2e(W, &&);
+	#undef W
+}
diff --git a/src/game/client/area.h b/src/game/client/area.h
new file mode 100644
index 000000000..2dafaa4e6
--- /dev/null
+++ b/src/game/client/area.h
@@ -0,0 +1,7 @@
+/* square area */
+struct area {
+	vec2 c; /* center */
+	int d; /* dimension */
+};
+
+int areahaspos(struct area *a, vec2 p);
diff --git a/src/game/client/components/controls.cpp b/src/game/client/components/controls.cpp
index 05d26098e..d1c73f4e5 100644
--- a/src/game/client/components/controls.cpp
+++ b/src/game/client/components/controls.cpp
@@ -12,6 +12,7 @@
 #include <game/client/components/scoreboard.h>
 #include <game/client/gameclient.h>
 #include <game/collision.h>
+#include <engine/client/ai.h>
 
 #include <base/vmath.h>
 
@@ -367,6 +368,19 @@ int CControls::SnapInput(int *pData)
 			Send = true;
 	}
 
+	if (ai_gaveinp) {
+		m_InputData[g_Config.m_ClDummy] = ai_inp;
+		Send = true;
+		ai_gaveinp = 0;
+	} else {
+		ai_inp = m_InputData[g_Config.m_ClDummy];
+		Send = false;
+	}
+	if (ai_selfkill) {
+		GameClient()->SendKill(-1);
+		ai_selfkill = 0;
+	}
+
 	// copy and return size
 	m_LastData[g_Config.m_ClDummy] = m_InputData[g_Config.m_ClDummy];
 
diff --git a/src/game/client/components/hud.cpp b/src/game/client/components/hud.cpp
index 35e9522e5..c27ea182c 100644
--- a/src/game/client/components/hud.cpp
+++ b/src/game/client/components/hud.cpp
@@ -3,6 +3,7 @@
 #include <engine/graphics.h>
 #include <engine/shared/config.h>
 #include <engine/textrender.h>
+#include <engine/client/ai.h>
 
 #include <game/client/animstate.h>
 #include <game/client/components/scoreboard.h>
@@ -874,6 +875,7 @@ void CHud::RenderPlayerState(const int ClientID)
 		}
 		TotalJumpsToDisplay = maximum(minimum(abs(pCharacter->m_Jumps), 10), 0);
 		AvailableJumpsToDisplay = maximum(minimum(UnusedJumps, TotalJumpsToDisplay), 0);
+		ai_availjumps = AvailableJumpsToDisplay;
 	}
 	else
 	{
diff --git a/src/game/client/gameclient.cpp b/src/game/client/gameclient.cpp
index d6c801442..5b616aac9 100644
--- a/src/game/client/gameclient.cpp
+++ b/src/game/client/gameclient.cpp
@@ -30,6 +30,7 @@
 #include "render.h"
 #include <game/localization.h>
 #include <game/version.h>
+#include <engine/client/ai.h>
 
 #include "gameclient.h"
 
@@ -1225,7 +1226,7 @@ void CGameClient::OnNewSnapshot()
 
 					if(pInfo->m_Local)
 					{
-						m_Snap.m_LocalClientID = Item.m_ID;
+						ai_CID = m_Snap.m_LocalClientID = Item.m_ID;
 						m_Snap.m_pLocalInfo = pInfo;
 
 						if(pInfo->m_Team == TEAM_SPECTATORS)
diff --git a/src/game/client/prediction/entities/character.cpp b/src/game/client/prediction/entities/character.cpp
index 54e739bdc..cd15c8ada 100644
--- a/src/game/client/prediction/entities/character.cpp
+++ b/src/game/client/prediction/entities/character.cpp
@@ -3,12 +3,52 @@
 #include <engine/shared/config.h>
 #include <game/generated/client_data.h>
 #include <game/mapitems.h>
+#include <game/client/gameclient.h>
+
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <poll.h>
+
+//for ai
+#include <engine/client/ai.h>
+#include <engine/client/fifo.h>
+#include <base/util.h>
+#include <base/cycbuf.h>
+#include <game/client/area.h>
 
 #include "character.h"
 #include "laser.h"
 #include "projectile.h"
 
+#define V2F "%d %d"
+#define V2A(V) (int)(V).x, (int)(V).y
+
 // Character, "physical" player's part
+intern struct area prevareabuf[32];
+intern struct area curarea;
+intern struct cycbuf prevareas;
+
+bool ColSF(CCollision *pCollision, vec2 Prev, vec2 Pos, int TILE) {
+//	CCollision *pCollision = pClient->Collision();
+	std::list<int> Indices = pCollision->GetMapIndices(Prev, Pos);
+	if(!Indices.empty())
+		for(int &Indice : Indices)
+		{
+			if(pCollision->GetTileIndex(Indice) == TILE)
+				return true;
+			if(pCollision->GetFTileIndex(Indice) == TILE)
+				return true;
+		}
+	else
+	{
+		if(pCollision->GetTileIndex(pCollision->GetPureMapIndex(Pos)) == TILE)
+			return true;
+		if(pCollision->GetFTileIndex(pCollision->GetPureMapIndex(Pos)) == TILE)
+			return true;
+	}
+	return false;
+}
 
 void CCharacter::SetWeapon(int W)
 {
@@ -553,13 +593,140 @@ void CCharacter::ResetInput()
 	m_LatestPrevInput = m_LatestInput = m_Input;
 }
 
+intern int
+ckareas(struct area *cur, struct cycbuf *prev, vec2 p)
+{
+	#define new new_ /* zogtib big troll */
+	struct area *a, new;
+	size_t i;
+
+	#define ARF V2F " %d"
+	#define ARA(A) V2A((A).c), (A).d
+
+//	printf("p:" V2F " -- " ARF, V2A(p), ARA(*cur));
+	new = *cur;
+	if (p.x < cur->c.x - cur->d)
+		new.c.x -= 2 * cur->d;
+	else if (p.x > cur->c.x + cur->d)
+		new.c.x += 2 * cur->d;
+	else if (p.y < cur->c.y - cur->d)
+		new.c.y -= 2 * cur->d;
+	else if (p.y > cur->c.y + cur->d)
+		new.c.y += 2 * cur->d;
+	else {
+		printf(" in\n");
+		return 0;
+	}
+
+//	printf("\n");
+	for (i = 1; i <= prev->nea; i++) {
+		a = (struct area *)cbelmat(prev, prev->fp + prev->nea - i);
+//		printf("pa[%d]: " ARF "\n", (int)i, ARA(*a));
+		if (areahaspos(a, p))
+			goto cut;
+	}
+//	printf("got to new area\n");
+	cbadd(prev, cur);
+	*cur = new;
+	return 1;
+cut:
+//	printf("move your a**\n");
+	prev->nea -= i;
+	*cur = *a;
+	return -(int)i;
+	#undef new
+}
+
 void CCharacter::Tick()
 {
+	static int haveread = 2;
+	struct pollfd pfd;
+	char inp[1024], *s;
+
+//	printf("m_ID: %d, ai_CID: %d\n", m_ID, ai_CID);
+	if (m_ID == ai_CID) {
+		int sk;
+		pfd.fd = fileno(fifoin.f);
+		pfd.events = POLLIN;
+//		ai_selfkill = 0;
+	ckinput:
+		switch (poll(&pfd, 1, 0)) {
+		case 1:
+			if (fgets(inp, sizeof inp, fifoin.f)) {
+//				printf("inp: %s\n", inp);
+				if ((s = strchr(inp, '\n')))
+					*s = 0;
+				sscanf(inp, "%d %d %d %d %d %d",
+					&ai_inp.m_Direction,
+					&ai_inp.m_TargetX,
+					&ai_inp.m_TargetY,
+					&ai_inp.m_Jump,
+					&ai_inp.m_Hook,
+					&sk);
+//					&ai_isdone);
+				ai_selfkill |= sk;
+	//			printf("%d %d %d\n",
+	//			ai_inp.m_Direction, ai_inp.m_TargetX, ai_inp.m_TargetY);
+				ai_gaveinp = 1;
+				haveread = 2;
+//				printf("haveread = 2\n");
+				goto ckinput;
+			}
+			break;
+		case 0:
+			if (haveread < 2)
+				haveread = 0;
+			break;
+		case -1:
+			perrn("poll: %s", fifoin.fnm);
+		}
+	}
+
+//	printf("haveread: %d\n", haveread);
+
 	DDRaceTick();
 
 	m_Core.m_Input = m_Input;
 	m_Core.Tick(true);
 
+	if (m_ID == ai_CID) {
+		static struct {
+			int freeze;
+			int start;
+			int finish;
+			int selfkill;
+			int area;
+		} rwd;
+
+//		if (!areahaspos(&curarea, m_Core.m_Pos) && !curarea.c.x && !curarea.c.y)
+		int i;
+		if ((i = ckareas(&curarea, &prevareas, m_Core.m_Pos)) < 0)
+			rwd.area = i;
+		else if (i > 0)
+			rwd.area = 1;
+		else
+			rwd.area = 0;
+
+		if (haveread) {
+			rwd.freeze = (ColSF(Collision(), m_PrevPos, m_Core.m_Pos, TILE_FREEZE)) ? 1 : 0;
+			rwd.start = (ColSF(Collision(), m_PrevPos, m_Core.m_Pos, TILE_START)) ? 1 : 0;
+			rwd.finish = (ColSF(Collision(), m_PrevPos, m_Core.m_Pos, TILE_FINISH)) ? 1 : 0;
+			rwd.selfkill = ai_selfkill ? 1 : 0;
+
+			fprintf(fifoout.f, V2F " " V2F " " V2F " %d %d %d" " %d %d %d %d\n",
+				V2A(m_Core.m_Pos), V2A(m_Core.m_Vel), V2A(m_Core.m_HookPos),
+				m_Core.m_HookState, m_Core.m_Direction, ai_availjumps,
+				rwd.freeze, rwd.start, rwd.finish, rwd.area);
+//			printf("cid: %d " V2F " " V2F " " V2F " %d %d %d" " %d %d %d\n",
+//				ai_CID,
+//				V2A(m_Core.m_Pos), V2A(m_Core.m_Vel), V2A(m_Core.m_HookPos),
+//				m_Core.m_HookState, m_Core.m_Direction, ai_availjumps,
+//				rwd.freeze, rwd.start, rwd.finish);
+			fflush(fifoout.f);
+			haveread = 0;
+		}
+	}
+
 	// handle Weapons
 	HandleWeapons();
 
@@ -1146,6 +1313,9 @@ CCharacter::CCharacter(CGameWorld *pGameWorld, int ID, CNetObj_Character *pChar,
 
 	m_LatestPrevInput = m_LatestInput = m_PrevInput = m_SavedInput = m_Input;
 
+	cbinit(&prevareas, sizeof(struct area), NELM(prevareabuf), prevareabuf);
+	curarea.d = 5 * 32;
+
 	ResetPrediction();
 	Read(pChar, pExtended, pExtendedDisplayInfo, false);
 }
@@ -1181,6 +1351,10 @@ void CCharacter::ResetPrediction()
 	}
 	m_LastWeaponSwitchTick = 0;
 	m_LastTuneZoneTick = 0;
+
+	/* for ai */
+	prevareas.nea = 0;
+	curarea.c = vec2{};
 }
 
 void CCharacter::Read(CNetObj_Character *pChar, CNetObj_DDNetCharacter *pExtended, CNetObj_DDNetCharacterDisplayInfo *pExtendedDisplayInfo, bool IsLocal)
diff --git a/src/game/server/gamecontroller.cpp b/src/game/server/gamecontroller.cpp
index 1f8c316ac..b01575171 100644
--- a/src/game/server/gamecontroller.cpp
+++ b/src/game/server/gamecontroller.cpp
@@ -97,6 +97,7 @@ void IGameController::DoActivityCheck()
 
 float IGameController::EvaluateSpawnPos(CSpawnEval *pEval, vec2 Pos, int DDTeam)
 {
+	return rand();
 	float Score = 0.0f;
 	CCharacter *pC = static_cast<CCharacter *>(GameServer()->m_World.FindFirst(CGameWorld::ENTTYPE_CHARACTER));
 	for(; pC; pC = (CCharacter *)pC->TypeNext())
diff --git a/src/tools/map_diff.cpp b/src/tools/map_diff.cpp
index 07dab55e0..da0358210 100644
--- a/src/tools/map_diff.cpp
+++ b/src/tools/map_diff.cpp
@@ -5,93 +5,59 @@
 #include <game/gamecore.h>
 #include <game/mapitems.h>
 
-bool Process(IStorage *pStorage, const char **pMapNames)
+#include <pnglite.h>
+
+#define eprintf(...) fprintf(stderr, __VA_ARGS__);
+
+bool Process(IStorage *pStorage, const char *mapfnm)
 {
-	CDataFileReader Maps[2];
-
-	for(int i = 0; i < 2; ++i)
-	{
-		if(!Maps[i].Open(pStorage, pMapNames[i], IStorage::TYPE_ABSOLUTE))
-		{
-			dbg_msg("map_compare", "error opening map '%s'", pMapNames[i]);
-			return false;
-		}
+	CDataFileReader Map;
 
-		CDataFileReader *pMap = &Maps[i];
-		// check version
-		CMapItemVersion *pVersion = (CMapItemVersion *)pMap->FindItem(MAPITEMTYPE_VERSION, 0);
-		if(pVersion && pVersion->m_Version != 1)
-			return false;
+	if (!Map.Open(pStorage, mapfnm, IStorage::TYPE_ABSOLUTE)) {
+		fprintf(stderr, "error opening map '%s'", mapfnm);
+		return false;
 	}
 
-	int Start[2], Num[2];
+	// check version
+	CMapItemVersion *pVersion = (CMapItemVersion *)Map.FindItem(MAPITEMTYPE_VERSION, 0);
+	if (pVersion && pVersion->m_Version != 1)
+		return false;
 
-	Maps[0].GetType(MAPITEMTYPE_LAYER, &Start[0], &Num[0]);
-	Maps[1].GetType(MAPITEMTYPE_LAYER, &Start[1], &Num[1]);
+	int Start, Num;
 
-	// ensure basic layout
-	if(Num[0] != Num[1])
-	{
-		dbg_msg("map_compare", "different layer numbers:");
-		for(int i = 0; i < 2; ++i)
-			dbg_msg("map_compare", "  \"%s\": %d layers", pMapNames[i], Num[i]);
-		return false;
-	}
+	Map.GetType(MAPITEMTYPE_LAYER, &Start, &Num);
 
-	// preload data
-	for(int j = 0; j < Num[0]; ++j)
-	{
-		CMapItemLayer *pItem[2];
-		CMapItemLayerTilemap *pTilemap[2];
-		for(int i = 0; i < 2; ++i)
-		{
-			pItem[i] = (CMapItemLayer *)Maps[i].GetItem(Start[i] + j, 0, 0);
-			pTilemap[i] = (CMapItemLayerTilemap *)pItem[i];
-			(void)(CTile *) Maps[i].GetData(pTilemap[i]->m_Data);
-		}
-	}
+	for (int j = 0; j < Num; ++j) {
+		CMapItemLayer *pItem;
+		CMapItemLayerTilemap *pTilemap;
+		CTile *pTile;
+		char aName[16];
 
-	// compare
-	for(int j = 0; j < Num[0]; ++j)
-	{
-		CMapItemLayer *pItem[2];
-		for(int i = 0; i < 2; ++i)
-			pItem[i] = (CMapItemLayer *)Maps[i].GetItem(Start[i] + j, 0, 0);
+		pItem = (CMapItemLayer *)Map.GetItem(Start + j, 0, 0);
+		pTilemap = (CMapItemLayerTilemap *)pItem;
+		if (!(pTilemap->m_Flags & TILESLAYERFLAG_GAME))
+			continue;
+		Map.GetData(pTilemap->m_Data);
 
-		if(pItem[0]->m_Type != LAYERTYPE_TILES)
+		if (pItem->m_Type != LAYERTYPE_TILES)
 			continue;
 
-		CMapItemLayerTilemap *pTilemap[2];
-		char aName[2][16];
+		IntsToStr(pTilemap->m_aName, sizeof(pTilemap->m_aName) / sizeof(int), aName);
 
-		for(int i = 0; i < 2; ++i)
-		{
-			pTilemap[i] = (CMapItemLayerTilemap *)pItem[i];
-			IntsToStr(pTilemap[i]->m_aName, sizeof(pTilemap[i]->m_aName) / sizeof(int), aName[i]);
-		}
+		pTile = (CTile *)Map.GetData(pTilemap->m_Data);
 
-		if(str_comp(aName[0], aName[1]) != 0 || pTilemap[0]->m_Width != pTilemap[1]->m_Width || pTilemap[0]->m_Height != pTilemap[1]->m_Height)
-		{
-			dbg_msg("map_compare", "different tile layers:");
-			for(int i = 0; i < 2; ++i)
-				dbg_msg("map_compare", "  \"%s\" (%dx%d)", aName[i], pTilemap[i]->m_Width, pTilemap[i]->m_Height);
-			return false;
-		}
-		CTile *pTile[2];
-		for(int i = 0; i < 2; ++i)
-			pTile[i] = (CTile *)Maps[i].GetData(pTilemap[i]->m_Data);
-
-		for(int y = 0; y < pTilemap[0]->m_Height; y++)
-		{
-			for(int x = 0; x < pTilemap[0]->m_Width; x++)
-			{
-				int pos = y * pTilemap[0]->m_Width + x;
-				if(pTile[0][pos].m_Index != pTile[1][pos].m_Index || pTile[0][pos].m_Flags != pTile[1][pos].m_Flags)
-				{
-					dbg_msg("map_compare", "[%d:%s] %dx%d: (index: %d, flags: %d) != (index: %d, flags: %d)", Num[0], aName[0], x, y, pTile[0][pos].m_Index, pTile[0][pos].m_Flags, pTile[1][pos].m_Index, pTile[0][pos].m_Flags);
-				}
+		int x, y, pos;
+		printf("%d %d\n", pTilemap->m_Width, pTilemap->m_Height);
+		for (y = 0; y < pTilemap->m_Height; y++) {
+			for (x = 0; x < pTilemap->m_Width; x++) {
+				pos = y * pTilemap->m_Width + x;
+//				printf("[%d:%s] %dx%d: (idx: %d, flgs: %d)\n", j, aName,
+//				printf("%d %d %d\n", x, y, pTile[pos].m_Index);
+				printf(&" %d"[!x], pTile[pos].m_Index);
 			}
+			printf("\n");
 		}
+		break;
 	}
 
 	return true;
@@ -103,20 +69,17 @@ int main(int argc, const char *argv[])
 	std::vector<std::shared_ptr<ILogger>> apLoggers;
 	apLoggers.push_back(std::shared_ptr<ILogger>(log_logger_stdout()));
 	IOHANDLE LogFile = io_open("map_diff.txt", IOFLAG_WRITE);
-	if(LogFile)
-	{
+
+	if (LogFile)
 		apLoggers.push_back(std::shared_ptr<ILogger>(log_logger_file(LogFile)));
-	}
 	log_set_global_logger(log_logger_collection(std::move(apLoggers)).release());
 
 	IStorage *pStorage = CreateLocalStorage();
 
-	if(argc != 3)
-	{
-		dbg_msg("usage", "%s map1 map2", argv[0]);
+	if (argc != 2) {
+		eprintf("usage: %s map\n", argv[0]);
 		return -1;
 	}
-	int Result = Process(pStorage, &argv[1]) ? 0 : 1;
-	cmdline_free(argc, argv);
-	return Result;
+
+	return Process(pStorage, argv[1]);
 }
